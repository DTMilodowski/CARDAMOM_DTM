###
## function to return x,y coordinate from an array which is nearest to a provided lat / long value
###

closest2d <- function (id,lat,long,lat_in,long_in,nos_dim) {

    # extract needed lat / long
    lat1=lat_in[id] ; long1=long_in[id]
    # calculate the distance between two points by Spherical law of the cosine
    # mean radius of earth in km
    R=6371  # 6378137 m (R source equitorial)
    # convert degrees to radians
    deg_to_rad=pi/180
    # check lat long system
    if (length(which(as.vector(long) > 180)) > 1) {stop("Input error closest2d: longitude should be -180 to +180")}

    if (nos_dim == 1) {
	## lat long are in single vectors repeating i.e. lat[1:10]=89.9,89.9,89.9... ; long[1:10]=-180,-160,-140....
	# loop through to find the smallest distance
	d_old=1e6
	# check for locations which exactly coincide, complete calculatuion and finally remove NaN generated by value "1"
	d = acos(sin(lat1*deg_to_rad)*sin(lat*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
	match = which(is.na(d) == TRUE) ; d[match] = 0 #; print(match)
	d = pmax(1e-6,d,na.rm=TRUE)
	output=which(d == min(d))[1] ; d_old=d[output] 
	if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
	rm(d_old)
    } else if (nos_dim == 2) {
	## lat and long are in two - dimensional arrays which co-varying 
	# loop through to find the smallest distance
	d = sin(lat1*deg_to_rad)*sin(as.vector(lat)*deg_to_rad)+cos(lat1*deg_to_rad)*cos(as.vector(lat)*deg_to_rad)*cos((as.vector(long)*deg_to_rad)-(long1*deg_to_rad))
	# check for locations which exactly coincide, complete calculatuion and finally remove NaN generated by value "1"
        d = acos(d)*R ; match = which(is.na(d) == TRUE) ; d[match] = 0 #; print(match)
	if (min(d) > 10) {print(paste("id = ",id," Minimum distance found (",round(min(d),digits=1),") is greater than 10 km from actual location"))}
	i=ceiling(which(d == min(d))/dim(lat)[1])
	j=which(d == min(d))-floor(which(d == min(d))/dim(lat)[1])*dim(lat)[1]
	output = list(j[1],i[1]) ; rm(i,j)
    } else if (nos_dim == 3) {
	## lat and long are in two 1-dimensional vectors but co-varying as in cartesian co-ordinates
	# loop through to find the smallest distance
	d_old=1e6
	for (j in seq(1, length(lat))) {
	    # convert all to radians
	    d = acos(sin(lat1*deg_to_rad)*sin(lat[j]*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat[j]*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
	    if (min(d) < d_old) {
		possible_i = which(d == min(d))
#print(possible_i) ; print(j) ; print(length(long)) ; print(length(lat))
		if (length(possible_i) > 1 & possible_i[1] == 1 & possible_i[length(possible_i)] == length(long)) {
		    possible_i = possible_i[which(long[possible_i] == long1)]
		} 
		output = list(possible_i[1],j) ; d_old=min(d)
	    }
	} # j loop
	if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
	rm(i,d_old)
    }

    # clean up
    rm(d,R,lat1,long1) # ; gc() ; gc()
    # return to the user
    return(output)

} # end of function
## Use byte compile
closest2d<-cmpfun(closest2d)